<html>
<head>
    <title>Auto Presenter</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <audio id="audio"></audio>
    <div class="grid justify-items-center h-screen bg-black">
        <div>
            <button id="start-button" class="text-white p-2 px-8 mt-5 border-white border-solid border-2 rounded-xl">
                Start
            </button>
        </div>
        <div class="mx-auto items-center">
            <h1 class="text-8xl font-bold text-white leading-snug" id="slide_contents"></h1>
        </div>
    </div>
</body>
<script>

const url = window.location.href.replace('http', 'ws').replace('https', 'wss') + 'ws/slides/';
console.log(url);
webSocket = new WebSocket(url);

webSocket.onmessage = function(e) {
    const data = JSON.parse(e.data);
    console.log(data)
    let slide_contents = data.slide.documents[0][0];
    document.querySelector('#slide_contents').innerText = slide_contents;
};

webSocket.onclose = function(e) {
    console.error('Chat socket closed unexpectedly');
};


// song_text = [
//     "You were the Word at the beginning",
//     "One with God the Lord Most High",
//     "Your hidden glory in creation",
//     "Now revealed in You our Christ",
//     "What a beautiful Name it is",
//     "What a beautiful Name it is",
//     "The Name of Jesus Christ my King",
//     "What a beautiful Name it",
//     "Nothing compares to this",
//     "What a beautiful Name it is",
//     "The Name of Jesus",
//     "You didn't want heaven without us",
//     "So Jesus, You brought heaven down",
//     "My sin was great, Your love was greater",
//     "What could separate us now",
//     "What a wonderful Name it is",
//     "What a wonderful Name it is",
//     "The Name of Jesus Christ my King",
//     "What a wonderful Name it is",
//     "Nothing compares to this",
//     "What a wonderful Name it is",
//     "The Name of Jesus",
//     "What a wonderful Name it is",
//     "The Name of Jesus",
//     "Death could not hold You",
//     "The veil tore before You",
// ];

// for (let i = 0; i < 10; i++) {
//     setTimeout(() => {
//         webSocket.send(JSON.stringify({
//             'text': song_text[i],
//             'audio': ''
//         }));
//     }, i * 1000);
// }
// setTimeout(() => {
//     webSocket.send(JSON.stringify({
//         'text': "What a beautiful name it is",
//         'audio': ''
//     }));
// }, 1000);

// Recording

const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition)();
recognition.lang = 'en-US';

recognition.onstart = () => {
    startButton.textContent = 'Listening...';
};

recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    // outputDiv.textContent = transcript;
    console.log("Transcript: ", transcript);
    webSocket.send(JSON.stringify({
        'text': transcript
    }));
};

recognition.onend = () => {
    startButton.textContent = 'Start';
};

let startButton = document.getElementById('start-button');
startButton.addEventListener('click', () => {
    recognition.start();
});


// let recorderButton = document.getElementById('recorder-button'); // the button to start and stop the recording
// let audioElement = document.getElementById('audio'); // the audio element that we will feed our recording to
// let webAudioRecorder; // our WebAudioRecorder.js recorder yet to be instantiated
// let currentlyRecording = false; // a boolean to keep track of whether recording is taking place
// let getUserMediaStream; // our stream from getUserMedia

// let recordedChunks = [];

// // listen for clicks on the record button to begin the stream and recording
// recorderButton.addEventListener('click', () => {
//   // the options object determining what media type(s) to capture
//   let options = { 'audio': true, 'video': false };
//   // only start the recording stream if there is not another recording in progress
//   if (currentlyRecording === false) {
//     // the built-in method for capturing audio/video from the user's device
//     // pass in the media capture options object and ask for permission to access the microphone
//     navigator.mediaDevices.getUserMedia(options)
//     .then(stream => {
//       currentlyRecording = true;
//       // if this is a subsequent recording, hide the HTML audio element
//       audioElement.controls = false;
//       // set this to stream so that we can access it outside the scope of the promise 
//       // when we need to stop the stream created by getUserMedia 
//       getUserMediaStream = stream;
//       // the AudioContext that will handle our audio stream
//       // if you're in Safari, you can't use the regular audio context so provide this line to use webkitAudioContext
//     //   let AudioContext = window.AudioContext ||  window.webkitAudioContext;
//     //   let audioContext = new AudioContext();
//     //   // an audio node that we can feed to a new WebAudioRecorder so we can record/encode the audio data
//     //   let source = audioContext.createMediaStreamSource(stream);

//       const options = { mimeType: "audio/webm" };
//       const mediaRecorder = new MediaRecorder(stream, options);

//       function download() {
//         const blob = new Blob(recordedChunks, {
//           type: "audio/webm",
//         });

//         console.log(blob);
//         webSocket.send(JSON.stringify({
//             'text': "What a beautiful name it is",
//             'audio': blob.toString()
//         }));

//         // const url = URL.createObjectURL(blob);
//         // const a = document.createElement("a");
//         // document.body.appendChild(a);
//         // a.style = "display: none";
//         // a.href = url;
//         // a.download = "test.webm";
//         // a.click();
//         // window.URL.revokeObjectURL(url);
//       }


//       function handleDataAvailable(event) {
//         console.log("data-available");
//         if (event.data.size > 0) {
//           recordedChunks.push(event.data);
//           // console.log(recordedChunks);
//           download();
//         } else {
//           // â€¦
//         }
//       }
//       mediaRecorder.ondataavailable = handleDataAvailable;
//       mediaRecorder.start();


//       // the creation of the recorder with its settings:
//     //   webAudioRecorder = new WebAudioRecorder(source, {
//     //     // workerDir: the directory where the WebAudioRecorder.js file lives
//     //     workerDir: 'web_audio_recorder_js/',
//     //     // encoding: type of encoding for our recording ('mp3', 'ogg', or 'wav')
//     //     encoding: 'mp3',
//     //     options: {
//     //       // encodeAfterRecord: our recording won't be usable unless we set this to true
//     //       encodeAfterRecord: true,
//     //       // mp3: bitRate: '160 is default, 320 is max quality'
//     //     //   mp3: { bitRate: '320' }
//     //     }
//     //   });


//       // the method that fires when the recording finishes (triggered by webAudioRecorder.finishRecording() below)
//       // the blob is the encoded audio file
//     //   webAudioRecorder.onComplete = (webAudioRecorder, blob) => {
//     //     // create a temporary URL that we can use as the src attribute for our audio element (audioElement)
//     //     let audioElementSource = window.URL.createObjectURL(blob);
//     //     // set this URL as the src attribute of our audio element
//     //     audioElement.src = audioElementSource;
//     //     // add controls so we can start and pause at will
//     //     audioElement.controls = true;
//     //     // reset the styles of the button's child div to look like a record button
//     //     recorderButtonDiv.style.backgroundColor = 'red';
//     //     recorderButtonDiv.style.borderRadius = '50%';
//     //   }
//     //   // handles and logs any errors that occur during the encoding/recording process
//     //   webAudioRecorder.onError = (webAudioRecorder, err) => {
//     //       console.error(err);
//     //   }
//       // method that initializes the recording
//     //   webAudioRecorder.startRecording();
//     })
//     // catch and log any errors in getUserMedia's promise
//     .catch(err => {
//         console.error(err);
//     });
//   }
//   else {
//     // set this to the array of audio tracks in our getUserMedia stream. In this case we only have one.
//     let audioTrack = getUserMediaStream.getAudioTracks()[0];
//     // stop that track and end the stream
//     // this is not absolutely necessary, but it stops the browser streaming audio inbetween recordings so you should probably do it
//     audioTrack.stop();
//     // this finishes things up and calls webAudioRecorder.onComplete
//     // webAudioRecorder.finishRecording();
//     currentlyRecording = false;
//   }
// });

</script>
</html>
